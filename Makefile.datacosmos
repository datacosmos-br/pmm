
###############################################################################
# Packaging Targets: Build completo (tarball, RPM, DEB e release)
###############################################################################

# Nome do pacote
PKG_NAME         := pmm
# Obt√©m a vers√£o sanitizada a partir do Git (usa somente a tag principal, sem sufixos)
VERSION          := $(shell git describe --tags --abbrev=0 | sed 's/^v//')
# Distribui√ß√£o ‚Äì ex.: "el7" para CentOS/OL7 (ajuste conforme necess√°rio)
DIST             := el7
# Arquitetura ‚Äì geralmente "noarch" para bin√°rios Go
ARCH             := noarch
# Diret√≥rio base do rpmbuild (normalmente ~/rpmbuild)
RPM_TOPDIR       := $(HOME)/rpmbuild

# Diret√≥rio do subm√≥dulo que cont√©m os arquivos de empacotamento (usaremos branch v3)
SUBMODULE_DIR    := pmm-submodules
# Define a branch do subm√≥dulo que deve ser usada
SUBMODULE_BRANCH := v3
SUBMODULES_DIR := $(SUBMODULE_DIR)/sources
BIN_DIR        := bin
SUBMODULES := $(shell find $(SUBMODULES_DIR) -maxdepth 1 -mindepth 1 -type d ! -name 'pmm-*')


# Agora, utilize os specs do reposit√≥rio local (n√£o os do submodule)
SPEC_FILE        := build/packages/rpm/server/SPECS/pmm-managed.spec

# Vari√°veis para o commit atual (full commit) e short commit
CUR_COMMIT     := $(shell git rev-parse HEAD)
SHORT_COMMIT   := $(shell echo $(CUR_COMMIT) | cut -c1-7)

.PHONY: update-submodules build-tarball build-rpm build-deb pkg-release pkg-all

## Atualiza os subm√≥dulos (se necess√°rio)
update-submodules:
	@echo "Verificando configura√ß√£o do subm√≥dulo..."
	
	# Verifica se o subm√≥dulo est√° registrado
	@if ! git config --file .gitmodules submodule.$(SUBMODULE_DIR).url > /dev/null; then \
		echo "Registrando subm√≥dulo..."; \
		git submodule add -b $(SUBMODULE_BRANCH) https://github.com/Percona-Lab/pmm-submodules.git $(SUBMODULE_DIR); \
	fi

	# Sincroniza URLs configuradas
	@git submodule sync --recursive -- $(SUBMODULE_DIR)

	# Inicializa se necess√°rio
	@if [ ! -f $(SUBMODULE_DIR)/.git ]; then \
		echo "Inicializando subm√≥dulo..."; \
		git submodule update --init --recursive -- $(SUBMODULE_DIR); \
	fi

	@echo "For√ßando atualiza√ß√£o para o HEAD do branch $(SUBMODULE_BRANCH)..."
	@cd $(SUBMODULE_DIR) && \
		git fetch --force origin "+refs/heads/$(SUBMODULE_BRANCH):refs/remotes/origin/$(SUBMODULE_BRANCH)" && \
		git checkout -B $(SUBMODULE_BRANCH) origin/$(SUBMODULE_BRANCH) && \
		git reset --hard origin/$(SUBMODULE_BRANCH) && \
		git clean -ffdx

	@echo "Atualizando subm√≥dulos recursivamente..."
	@git submodule update --recursive --remote --checkout --force

	@echo "Estado final verificado:"
	@git submodule status --recursive

###############################################################################
# Submodule Build Configuration
###############################################################################

# Formato: <nome>,<diretorio>,<comandos>,<binarios (padr√µes separados por |)>
SUBMODULE_CONFIGS ?= \
    azure_metrics,$(SUBMODULES_DIR)/azure_metrics_exporter/src/github.com/percona/azure_metrics_exporter,"make build","azure_metrics_exporter|tools/*_helper" \
    grafana,$(SUBMODULES_DIR)/grafana/src/github.com/grafana/grafana,"make build-go","bin/grafana-*" \
    node_exporter,$(SUBMODULES_DIR)/node_exporter/src/github.com/prometheus/node_exporter,"make build","node_exporter" \
    toolkit,$(SUBMODULES_DIR)/percona-toolkit/src/github.com/percona/percona-toolkit,"perl Makefile.PL && make","bin/pt-*"

# Delimitadores
FIELD_SEP := ,
BIN_SEP := |

###############################################################################
# Submodule Build System
###############################################################################

.PHONY: build-submodules clean-bin list-targets

define NEWLINE


endef

## Compila subm√≥dulos com m√∫ltiplos bin√°rios
build-submodules: update-submodules
	@echo "üöÄ Iniciando constru√ß√£o de subm√≥dulos..."
	@mkdir -p $(BIN_DIR)
	$(foreach cfg,$(subst \,, ,$(SUBMODULE_CONFIGS)), \
		$(eval _fields := $(subst $(FIELD_SEP), ,$(cfg))) \
		$(eval name := $(word 1,$(_fields))) \
		$(eval dir := $(word 2,$(_fields))) \
		$(eval cmds := $(subst ",,$(word 3,$(_fields)))) \
		$(eval bins := $(subst $(BIN_SEP), ,$(subst ",,$(word 4,$(_fields))))) \
		\
		@echo "$(NEWLINE)üîß Processando [$(name)]"; \
		@echo "üìÇ Diret√≥rio: $(dir)"; \
		if [ -d "$(dir)" ]; then \
			echo "üõ†Ô∏è  Executando: $(cmds)"; \
			(cd "$(dir)" && eval "$(cmds)") || exit 1; \
			echo "üì¶ Bin√°rios para copiar: $(bins)"; \
			$(foreach pattern,$(bins), \
				$(eval full_pattern := $(dir)/$(pattern)) \
				@echo "üîç Procurando: $(full_pattern)"; \
				found=0; \
				for file in $$(find "$(dir)" -type f -executable -path "$(full_pattern)" 2>/dev/null); do \
					found=1; \
					echo "‚ö° Copiando: $$file"; \
					cp -v "$$file" $(BIN_DIR)/; \
				done; \
				if [ $$found -eq 0 ]; then \
					echo "‚ö†Ô∏è  Nenhum bin√°rio encontrado para: $(pattern)"; \
				fi; \
			) \
		else \
			echo "‚ùå Diret√≥rio n√£o encontrado!"; \
			exit 1; \
		fi; \
	)
	@echo "$(NEWLINE)‚úÖ Constru√ß√£o conclu√≠da! Resultados:"
	@tree -h $(BIN_DIR)

## Lista todos os targets configurados
list-targets:
	@echo "üéØ Targets configurados:"
	@$(foreach cfg,$(subst \,, ,$(SUBMODULE_CONFIGS)), \
		$(eval name := $(word 1,$(subst $(FIELD_SEP), ,$(cfg)))) \
		echo "- $(name)"; \
	)

## Limpa bin√°rios
clean-bin:
	@echo "üßπ Limpando bin√°rios..."
	rm -rf $(BIN_DIR)

## Cria o tarball do c√≥digo-fonte usando git archive (que respeita o .gitignore)
build-tarball: build-submodules
	@echo "Criando tarball do c√≥digo-fonte..."
	@mkdir -p $(RPM_TOPDIR)/SOURCES
	# Gera o tarball com prefixo baseado no SHORT_COMMIT (ajuste cr√≠tico)
	git archive --format=tar --prefix=$(PKG_NAME)-$(CUR_COMMIT)/ HEAD > $(PKG_NAME)-$(SHORT_COMMIT).tar
	gzip -f $(PKG_NAME)-$(SHORT_COMMIT).tar
	@mv $(PKG_NAME)-$(SHORT_COMMIT).tar.gz $(RPM_TOPDIR)/SOURCES/
	@echo "Tarball criado em $(RPM_TOPDIR)/SOURCES/$(PKG_NAME)-$(SHORT_COMMIT).tar.gz"

## Configura o ambiente de rpmbuild, copia o arquivo .spec local e executa o rpmbuild
build-rpm: build-tarball
	@echo "Configurando ambiente de rpmbuild..."
	@mkdir -p $(RPM_TOPDIR)/{BUILD,RPMS,SPECS,SRPMS}
	@if [ ! -f "$(SPEC_FILE)" ]; then \
	  echo "Erro: Arquivo spec n√£o encontrado em $(SPEC_FILE)"; \
	  exit 1; \
	else \
	  echo "Arquivo spec encontrado: $(SPEC_FILE)"; \
	fi
	@echo "Copiando arquivo .spec..."
	@cp $(SPEC_FILE) $(RPM_TOPDIR)/SPECS/
	# @echo "Atualizando macros de commit no arquivo spec..."
	sed -i "s/^%global commit.*/%global commit          $(CUR_COMMIT)/" $(RPM_TOPDIR)/SPECS/$(notdir $(SPEC_FILE))
	@echo "Executando rpmbuild..."
	rpmbuild -ba $(RPM_TOPDIR)/SPECS/$(notdir $(SPEC_FILE)) \
	  --define "version $(VERSION)" \
	  --define "dist $(DIST)" \
	  --define "commit $(CUR_COMMIT)" \
	  --define "shortcommit $(SHORT_COMMIT)" \
	  --define "_topdir $(RPM_TOPDIR)"
	@echo "Pacote RPM gerado em $(RPM_TOPDIR)/RPMS/$(ARCH)/"

## Converte o pacote RPM gerado para um pacote DEB utilizando alien
build-deb: build-rpm
	@echo "Convertendo RPM para DEB..."
	alien -k --verbose --to-deb $(RPM_TOPDIR)/RPMS/$(ARCH)/*.rpm
	@echo "Pacote DEB gerado."

## Consolida os artefatos (tarball, RPM e DEB) em um diret√≥rio "release"
pkg-release: build-deb
	@echo "Organizando artefatos para release..."
	@mkdir -p release
	@cp $(RPM_TOPDIR)/SOURCES/$(PKG_NAME)-$(CUR_COMMIT).tar.gz release/
	@cp $(RPM_TOPDIR)/RPMS/$(ARCH)/*.rpm release/
	@cp $(PKG_NAME)*.deb release/
	@echo "Artefatos consolidados no diret√≥rio 'release'."

## Executa todas as etapas de empacotamento
pkg-all: update-submodules build-tarball build-rpm build-deb pkg-release
	@echo "Build completo de pacotes finalizado."

